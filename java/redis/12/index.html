<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.42">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>Redis 通讯协议及事件处理机制 | zmn.cn</title><meta name="description" content="Redis 通讯协议及事件处理机制">
    <link rel="modulepreload" href="/doc/assets/app.40df414d.js"><link rel="modulepreload" href="/doc/assets/index.html.d37ad707.js"><link rel="modulepreload" href="/doc/assets/index.html.93d3f714.js"><link rel="prefetch" href="/doc/assets/index.html.ac157e58.js"><link rel="prefetch" href="/doc/assets/index.html.795c9140.js"><link rel="prefetch" href="/doc/assets/index.html.fd51b8b2.js"><link rel="prefetch" href="/doc/assets/index.html.0c15a99b.js"><link rel="prefetch" href="/doc/assets/index.html.0c59ef61.js"><link rel="prefetch" href="/doc/assets/index.html.f10e9c63.js"><link rel="prefetch" href="/doc/assets/index.html.b5bfa26a.js"><link rel="prefetch" href="/doc/assets/index.html.e8912321.js"><link rel="prefetch" href="/doc/assets/index.html.e524e2c7.js"><link rel="prefetch" href="/doc/assets/index.html.e2c03529.js"><link rel="prefetch" href="/doc/assets/index.html.1a75e17e.js"><link rel="prefetch" href="/doc/assets/index.html.27d315d2.js"><link rel="prefetch" href="/doc/assets/index.html.8527be29.js"><link rel="prefetch" href="/doc/assets/index.html.5603dc63.js"><link rel="prefetch" href="/doc/assets/index.html.a735b5dd.js"><link rel="prefetch" href="/doc/assets/index.html.68217935.js"><link rel="prefetch" href="/doc/assets/index.html.79799519.js"><link rel="prefetch" href="/doc/assets/index.html.6881f0e6.js"><link rel="prefetch" href="/doc/assets/index.html.e7ff66c5.js"><link rel="prefetch" href="/doc/assets/index.html.b3989c09.js"><link rel="prefetch" href="/doc/assets/index.html.90a11c7e.js"><link rel="prefetch" href="/doc/assets/index.html.e552d764.js"><link rel="prefetch" href="/doc/assets/index.html.a2e921be.js"><link rel="prefetch" href="/doc/assets/index.html.40de4d57.js"><link rel="prefetch" href="/doc/assets/index.html.8dfb5661.js"><link rel="prefetch" href="/doc/assets/index.html.0b633e02.js"><link rel="prefetch" href="/doc/assets/index.html.325a81ac.js"><link rel="prefetch" href="/doc/assets/index.html.fc94b663.js"><link rel="prefetch" href="/doc/assets/index.html.a61a14dc.js"><link rel="prefetch" href="/doc/assets/index.html.915b115c.js"><link rel="prefetch" href="/doc/assets/index.html.74c3962d.js"><link rel="prefetch" href="/doc/assets/index.html.50e666c4.js"><link rel="prefetch" href="/doc/assets/index.html.bd0865d1.js"><link rel="prefetch" href="/doc/assets/index.html.670a8d54.js"><link rel="prefetch" href="/doc/assets/index.html.267a5925.js"><link rel="prefetch" href="/doc/assets/index.html.820a240a.js"><link rel="prefetch" href="/doc/assets/index.html.956e3861.js"><link rel="prefetch" href="/doc/assets/index.html.1eb9b84f.js"><link rel="prefetch" href="/doc/assets/index.html.085c7b3b.js"><link rel="prefetch" href="/doc/assets/index.html.cc6b0c3f.js"><link rel="prefetch" href="/doc/assets/index.html.878a89e3.js"><link rel="prefetch" href="/doc/assets/index.html.4349d3a7.js"><link rel="prefetch" href="/doc/assets/index.html.ad70fd8f.js"><link rel="prefetch" href="/doc/assets/index.html.ae8f6e96.js"><link rel="prefetch" href="/doc/assets/index.html.5904c85d.js"><link rel="prefetch" href="/doc/assets/index.html.67ad7772.js"><link rel="prefetch" href="/doc/assets/index.html.1fb78180.js"><link rel="prefetch" href="/doc/assets/index.html.79837727.js"><link rel="prefetch" href="/doc/assets/index.html.3b548d45.js"><link rel="prefetch" href="/doc/assets/index.html.3a65bcaf.js"><link rel="prefetch" href="/doc/assets/index.html.636ab4d4.js"><link rel="prefetch" href="/doc/assets/index.html.8c20145c.js"><link rel="prefetch" href="/doc/assets/index.html.5cc28277.js"><link rel="prefetch" href="/doc/assets/index.html.587df9cf.js"><link rel="prefetch" href="/doc/assets/index.html.cffff73c.js"><link rel="prefetch" href="/doc/assets/index.html.0faea7db.js"><link rel="prefetch" href="/doc/assets/index.html.9ec36555.js"><link rel="prefetch" href="/doc/assets/index.html.4fbceb17.js"><link rel="prefetch" href="/doc/assets/index.html.a8892ad4.js"><link rel="prefetch" href="/doc/assets/index.html.1a7d6859.js"><link rel="prefetch" href="/doc/assets/index.html.5c08cce8.js"><link rel="prefetch" href="/doc/assets/index.html.ff1641e6.js"><link rel="prefetch" href="/doc/assets/index.html.10100559.js"><link rel="prefetch" href="/doc/assets/index.html.eca48ebd.js"><link rel="prefetch" href="/doc/assets/index.html.d9180794.js"><link rel="prefetch" href="/doc/assets/Spring.html.41ca96bd.js"><link rel="prefetch" href="/doc/assets/SpringBoot.html.c063ae1a.js"><link rel="prefetch" href="/doc/assets/SpringBoot源码.html.cdd45461.js"><link rel="prefetch" href="/doc/assets/SpringBoot高级.html.b3e5002b.js"><link rel="prefetch" href="/doc/assets/SpringMVC.html.25759dd3.js"><link rel="prefetch" href="/doc/assets/SpringSecurity.html.2ba8791d.js"><link rel="prefetch" href="/doc/assets/index.html.3afa53b5.js"><link rel="prefetch" href="/doc/assets/index.html.1963ae5c.js"><link rel="prefetch" href="/doc/assets/index.html.657aec84.js"><link rel="prefetch" href="/doc/assets/index.html.871b2105.js"><link rel="prefetch" href="/doc/assets/index.html.46266feb.js"><link rel="prefetch" href="/doc/assets/index.html.019ddb74.js"><link rel="prefetch" href="/doc/assets/index.html.2636a08e.js"><link rel="prefetch" href="/doc/assets/index.html.c6a50762.js"><link rel="prefetch" href="/doc/assets/index.html.6632d187.js"><link rel="prefetch" href="/doc/assets/index.html.480096df.js"><link rel="prefetch" href="/doc/assets/index.html.7bf9c484.js"><link rel="prefetch" href="/doc/assets/index.html.1ca63bf8.js"><link rel="prefetch" href="/doc/assets/index.html.ee1ff92b.js"><link rel="prefetch" href="/doc/assets/index.html.d1efbe95.js"><link rel="prefetch" href="/doc/assets/index.html.d302d742.js"><link rel="prefetch" href="/doc/assets/index.html.73b0a46e.js"><link rel="prefetch" href="/doc/assets/index.html.9b9e7b22.js"><link rel="prefetch" href="/doc/assets/index.html.5080b714.js"><link rel="prefetch" href="/doc/assets/index.html.e2de7b5a.js"><link rel="prefetch" href="/doc/assets/index.html.5a365a3f.js"><link rel="prefetch" href="/doc/assets/index.html.ea186b24.js"><link rel="prefetch" href="/doc/assets/index.html.da1b811a.js"><link rel="prefetch" href="/doc/assets/index.html.ba20a9fa.js"><link rel="prefetch" href="/doc/assets/index.html.23e205db.js"><link rel="prefetch" href="/doc/assets/index.html.92cefa25.js"><link rel="prefetch" href="/doc/assets/index.html.0519d6c0.js"><link rel="prefetch" href="/doc/assets/index.html.df3e94ce.js"><link rel="prefetch" href="/doc/assets/index.html.850ddff2.js"><link rel="prefetch" href="/doc/assets/index.html.060bc27e.js"><link rel="prefetch" href="/doc/assets/index.html.e9e53a65.js"><link rel="prefetch" href="/doc/assets/index.html.e03489a4.js"><link rel="prefetch" href="/doc/assets/index.html.5730a56d.js"><link rel="prefetch" href="/doc/assets/index.html.b2f4abe8.js"><link rel="prefetch" href="/doc/assets/index.html.cafd859a.js"><link rel="prefetch" href="/doc/assets/index.html.c8328127.js"><link rel="prefetch" href="/doc/assets/index.html.887c0664.js"><link rel="prefetch" href="/doc/assets/index.html.4bf77624.js"><link rel="prefetch" href="/doc/assets/index.html.0e7972f9.js"><link rel="prefetch" href="/doc/assets/index.html.265aab2e.js"><link rel="prefetch" href="/doc/assets/index.html.ec74946d.js"><link rel="prefetch" href="/doc/assets/index.html.e3a2fec1.js"><link rel="prefetch" href="/doc/assets/index.html.36b699b6.js"><link rel="prefetch" href="/doc/assets/index.html.fdaf1cae.js"><link rel="prefetch" href="/doc/assets/index.html.ae3b119d.js"><link rel="prefetch" href="/doc/assets/index.html.b6c53f53.js"><link rel="prefetch" href="/doc/assets/index.html.0773f88d.js"><link rel="prefetch" href="/doc/assets/index.html.d571ef54.js"><link rel="prefetch" href="/doc/assets/index.html.86f9e908.js"><link rel="prefetch" href="/doc/assets/index.html.60f723ac.js"><link rel="prefetch" href="/doc/assets/index.html.01581c9b.js"><link rel="prefetch" href="/doc/assets/index.html.d96d738e.js"><link rel="prefetch" href="/doc/assets/index.html.5ddae78d.js"><link rel="prefetch" href="/doc/assets/index.html.7c0814ab.js"><link rel="prefetch" href="/doc/assets/index.html.965b7fff.js"><link rel="prefetch" href="/doc/assets/vue3快速上手.html.8773c5ea.js"><link rel="prefetch" href="/doc/assets/index.html.b2090b45.js"><link rel="prefetch" href="/doc/assets/index.html.f6fbe2a7.js"><link rel="prefetch" href="/doc/assets/index.html.5079d83e.js"><link rel="prefetch" href="/doc/assets/index.html.0e7d3814.js"><link rel="prefetch" href="/doc/assets/index.html.236535af.js"><link rel="prefetch" href="/doc/assets/index.html.e7057fa7.js"><link rel="prefetch" href="/doc/assets/index.html.0dfecf7e.js"><link rel="prefetch" href="/doc/assets/index.html.ba833381.js"><link rel="prefetch" href="/doc/assets/404.html.93146c89.js"><link rel="prefetch" href="/doc/assets/index.html.3b7265f0.js"><link rel="prefetch" href="/doc/assets/index.html.f94b83e6.js"><link rel="prefetch" href="/doc/assets/index.html.478d12bf.js"><link rel="prefetch" href="/doc/assets/index.html.9eee768a.js"><link rel="prefetch" href="/doc/assets/index.html.2b8b2ed7.js"><link rel="prefetch" href="/doc/assets/index.html.a370c4da.js"><link rel="prefetch" href="/doc/assets/index.html.4078504f.js"><link rel="prefetch" href="/doc/assets/index.html.0a470d26.js"><link rel="prefetch" href="/doc/assets/index.html.70589c68.js"><link rel="prefetch" href="/doc/assets/index.html.3e00e696.js"><link rel="prefetch" href="/doc/assets/index.html.a2857e37.js"><link rel="prefetch" href="/doc/assets/index.html.11a24d88.js"><link rel="prefetch" href="/doc/assets/index.html.13fcd6dc.js"><link rel="prefetch" href="/doc/assets/index.html.bb926e52.js"><link rel="prefetch" href="/doc/assets/index.html.83c356d4.js"><link rel="prefetch" href="/doc/assets/index.html.9093f441.js"><link rel="prefetch" href="/doc/assets/index.html.99329590.js"><link rel="prefetch" href="/doc/assets/index.html.a25f2824.js"><link rel="prefetch" href="/doc/assets/index.html.5dd4e8e8.js"><link rel="prefetch" href="/doc/assets/index.html.80a1a8a8.js"><link rel="prefetch" href="/doc/assets/index.html.e6aaf5e4.js"><link rel="prefetch" href="/doc/assets/index.html.4b4f53af.js"><link rel="prefetch" href="/doc/assets/index.html.63d82858.js"><link rel="prefetch" href="/doc/assets/index.html.02f66c42.js"><link rel="prefetch" href="/doc/assets/index.html.b02e0cb9.js"><link rel="prefetch" href="/doc/assets/index.html.b2cf2462.js"><link rel="prefetch" href="/doc/assets/index.html.4d88523a.js"><link rel="prefetch" href="/doc/assets/index.html.b6d3a8c2.js"><link rel="prefetch" href="/doc/assets/index.html.8e3bc1fc.js"><link rel="prefetch" href="/doc/assets/index.html.593a1904.js"><link rel="prefetch" href="/doc/assets/index.html.d0fdf009.js"><link rel="prefetch" href="/doc/assets/index.html.bb125db3.js"><link rel="prefetch" href="/doc/assets/index.html.7a967c9a.js"><link rel="prefetch" href="/doc/assets/index.html.ca6b22e1.js"><link rel="prefetch" href="/doc/assets/index.html.e1c469a1.js"><link rel="prefetch" href="/doc/assets/index.html.ff09b3af.js"><link rel="prefetch" href="/doc/assets/index.html.ec4bbb87.js"><link rel="prefetch" href="/doc/assets/index.html.12c1e355.js"><link rel="prefetch" href="/doc/assets/index.html.8a4045e6.js"><link rel="prefetch" href="/doc/assets/index.html.b54dc8a6.js"><link rel="prefetch" href="/doc/assets/index.html.721d96fd.js"><link rel="prefetch" href="/doc/assets/index.html.d855e8ed.js"><link rel="prefetch" href="/doc/assets/index.html.17fbd68b.js"><link rel="prefetch" href="/doc/assets/index.html.ad5ccf5a.js"><link rel="prefetch" href="/doc/assets/index.html.130dead3.js"><link rel="prefetch" href="/doc/assets/index.html.0bcc78cc.js"><link rel="prefetch" href="/doc/assets/index.html.557897f7.js"><link rel="prefetch" href="/doc/assets/index.html.1d57cd02.js"><link rel="prefetch" href="/doc/assets/index.html.df77ede5.js"><link rel="prefetch" href="/doc/assets/index.html.ac04a9ed.js"><link rel="prefetch" href="/doc/assets/index.html.037f3861.js"><link rel="prefetch" href="/doc/assets/index.html.08a635f2.js"><link rel="prefetch" href="/doc/assets/index.html.af40cb25.js"><link rel="prefetch" href="/doc/assets/index.html.7b09b414.js"><link rel="prefetch" href="/doc/assets/index.html.ca416dcc.js"><link rel="prefetch" href="/doc/assets/index.html.f5eae5e4.js"><link rel="prefetch" href="/doc/assets/index.html.acf5622e.js"><link rel="prefetch" href="/doc/assets/index.html.77c30969.js"><link rel="prefetch" href="/doc/assets/index.html.ff8fef88.js"><link rel="prefetch" href="/doc/assets/index.html.b03ad9ee.js"><link rel="prefetch" href="/doc/assets/index.html.883bb815.js"><link rel="prefetch" href="/doc/assets/index.html.e5048f53.js"><link rel="prefetch" href="/doc/assets/index.html.80bf8279.js"><link rel="prefetch" href="/doc/assets/index.html.411d2f13.js"><link rel="prefetch" href="/doc/assets/index.html.e55b3889.js"><link rel="prefetch" href="/doc/assets/Spring.html.2f3df8d9.js"><link rel="prefetch" href="/doc/assets/SpringBoot.html.9cb899e2.js"><link rel="prefetch" href="/doc/assets/SpringBoot源码.html.6dd51782.js"><link rel="prefetch" href="/doc/assets/SpringBoot高级.html.74275d08.js"><link rel="prefetch" href="/doc/assets/SpringMVC.html.cf650f7b.js"><link rel="prefetch" href="/doc/assets/SpringSecurity.html.1e2f9882.js"><link rel="prefetch" href="/doc/assets/index.html.8489e95c.js"><link rel="prefetch" href="/doc/assets/index.html.4fc255fb.js"><link rel="prefetch" href="/doc/assets/index.html.6e298d1f.js"><link rel="prefetch" href="/doc/assets/index.html.dfb5c354.js"><link rel="prefetch" href="/doc/assets/index.html.55c13f7d.js"><link rel="prefetch" href="/doc/assets/index.html.9746da44.js"><link rel="prefetch" href="/doc/assets/index.html.5cad0d30.js"><link rel="prefetch" href="/doc/assets/index.html.a5a742fd.js"><link rel="prefetch" href="/doc/assets/index.html.2d7d46f5.js"><link rel="prefetch" href="/doc/assets/index.html.4fd15fc0.js"><link rel="prefetch" href="/doc/assets/index.html.5cf91540.js"><link rel="prefetch" href="/doc/assets/index.html.3d50e978.js"><link rel="prefetch" href="/doc/assets/index.html.21ff9d3b.js"><link rel="prefetch" href="/doc/assets/index.html.47b83ec4.js"><link rel="prefetch" href="/doc/assets/index.html.bc304f81.js"><link rel="prefetch" href="/doc/assets/index.html.b2a59940.js"><link rel="prefetch" href="/doc/assets/index.html.13415a43.js"><link rel="prefetch" href="/doc/assets/index.html.100ec837.js"><link rel="prefetch" href="/doc/assets/index.html.3472a443.js"><link rel="prefetch" href="/doc/assets/index.html.33aece6b.js"><link rel="prefetch" href="/doc/assets/index.html.e61dd289.js"><link rel="prefetch" href="/doc/assets/index.html.64183ae2.js"><link rel="prefetch" href="/doc/assets/index.html.446a1818.js"><link rel="prefetch" href="/doc/assets/index.html.97ea4a5c.js"><link rel="prefetch" href="/doc/assets/index.html.a6ef03fb.js"><link rel="prefetch" href="/doc/assets/index.html.3920cc47.js"><link rel="prefetch" href="/doc/assets/index.html.34f4e287.js"><link rel="prefetch" href="/doc/assets/index.html.1351290b.js"><link rel="prefetch" href="/doc/assets/index.html.84a20a4f.js"><link rel="prefetch" href="/doc/assets/index.html.e55a3317.js"><link rel="prefetch" href="/doc/assets/index.html.a5eeaab0.js"><link rel="prefetch" href="/doc/assets/index.html.a8d854c3.js"><link rel="prefetch" href="/doc/assets/index.html.74d28158.js"><link rel="prefetch" href="/doc/assets/index.html.9b6544ca.js"><link rel="prefetch" href="/doc/assets/index.html.ea3deaa2.js"><link rel="prefetch" href="/doc/assets/index.html.f5114c18.js"><link rel="prefetch" href="/doc/assets/index.html.ca8dada1.js"><link rel="prefetch" href="/doc/assets/index.html.0d3a5370.js"><link rel="prefetch" href="/doc/assets/index.html.13e899ea.js"><link rel="prefetch" href="/doc/assets/index.html.4f4461aa.js"><link rel="prefetch" href="/doc/assets/index.html.b6ced39d.js"><link rel="prefetch" href="/doc/assets/index.html.6c0283f0.js"><link rel="prefetch" href="/doc/assets/index.html.01661ebc.js"><link rel="prefetch" href="/doc/assets/index.html.657c6ed2.js"><link rel="prefetch" href="/doc/assets/index.html.f5f7aed0.js"><link rel="prefetch" href="/doc/assets/index.html.cdd6e499.js"><link rel="prefetch" href="/doc/assets/index.html.2d661523.js"><link rel="prefetch" href="/doc/assets/index.html.6893b4fb.js"><link rel="prefetch" href="/doc/assets/index.html.566e406c.js"><link rel="prefetch" href="/doc/assets/index.html.1357e2d3.js"><link rel="prefetch" href="/doc/assets/index.html.d910030e.js"><link rel="prefetch" href="/doc/assets/index.html.4d5146a8.js"><link rel="prefetch" href="/doc/assets/index.html.d830c4f5.js"><link rel="prefetch" href="/doc/assets/index.html.b1bef10b.js"><link rel="prefetch" href="/doc/assets/vue3快速上手.html.d36d3c30.js"><link rel="prefetch" href="/doc/assets/index.html.1e6ab806.js"><link rel="prefetch" href="/doc/assets/index.html.4125d933.js"><link rel="prefetch" href="/doc/assets/index.html.c5dc4567.js"><link rel="prefetch" href="/doc/assets/index.html.451edb2d.js"><link rel="prefetch" href="/doc/assets/index.html.a665dde3.js"><link rel="prefetch" href="/doc/assets/index.html.5ba5e8a1.js"><link rel="prefetch" href="/doc/assets/index.html.23b6b000.js"><link rel="prefetch" href="/doc/assets/index.html.629d6531.js"><link rel="prefetch" href="/doc/assets/404.html.d315880d.js"><link rel="prefetch" href="/doc/assets/404.bebaa092.js"><link rel="prefetch" href="/doc/assets/Layout.4134e473.js">
    <link rel="stylesheet" href="/doc/assets/style.83db67df.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/doc/" class=""><img class="logo" src="https://cdn-statics.zmn.cn/_nuxt/img/logo_web.b793f2a.png" alt="zmn.cn"><span class="site-name can-hide">zmn.cn</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/doc/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java"><span class="title">Java</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java"><span class="title">Java</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/doc/java/kafka/" class="" aria-label="Kafka"><!--[--><!--]--> Kafka <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/doc/java/redis/" class="router-link-active" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/doc/java/skywalking/" class="" aria-label="SkyWalking"><!--[--><!--]--> SkyWalking <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/doc/java/es/01/" class="" aria-label="ElasticSearch"><!--[--><!--]--> ElasticSearch <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/doc/java/drools/" class="" aria-label="Drools"><!--[--><!--]--> Drools <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/doc/java/jvm/01/" class="" aria-label="JVM"><!--[--><!--]--> JVM <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="BigData"><span class="title">BigData</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="BigData"><span class="title">BigData</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/doc/bigdata/hadoop/core/hadoop/01/" class="" aria-label="Hadoop"><!--[--><!--]--> Hadoop <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/doc/bigdata/scala/01base/" class="" aria-label="Scala"><!--[--><!--]--> Scala <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/doc/bigdata/spark/core/base/" class="" aria-label="Spark"><!--[--><!--]--> Spark <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/faustine8/doc" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/doc/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Java"><span class="title">Java</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Java"><span class="title">Java</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/doc/java/kafka/" class="" aria-label="Kafka"><!--[--><!--]--> Kafka <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/doc/java/redis/" class="router-link-active" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/doc/java/skywalking/" class="" aria-label="SkyWalking"><!--[--><!--]--> SkyWalking <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/doc/java/es/01/" class="" aria-label="ElasticSearch"><!--[--><!--]--> ElasticSearch <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/doc/java/drools/" class="" aria-label="Drools"><!--[--><!--]--> Drools <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/doc/java/jvm/01/" class="" aria-label="JVM"><!--[--><!--]--> JVM <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="BigData"><span class="title">BigData</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="BigData"><span class="title">BigData</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/doc/bigdata/hadoop/core/hadoop/01/" class="" aria-label="Hadoop"><!--[--><!--]--> Hadoop <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/doc/bigdata/scala/01base/" class="" aria-label="Scala"><!--[--><!--]--> Scala <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/doc/bigdata/spark/core/base/" class="" aria-label="Spark"><!--[--><!--]--> Spark <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/faustine8/doc" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">Redis 通讯协议及事件处理机制 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/doc/java/redis/12/#_1-通信协议" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. 通信协议"><!--[--><!--]--> 1. 通信协议 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/doc/java/redis/12/#_1-1-请求响应模式" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 请求响应模式"><!--[--><!--]--> 1.1 请求响应模式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/doc/java/redis/12/#_1-2-请求数据格式" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 请求数据格式"><!--[--><!--]--> 1.2 请求数据格式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/doc/java/redis/12/#_1-3-命令处理流程" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 命令处理流程"><!--[--><!--]--> 1.3 命令处理流程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/doc/java/redis/12/#_1-4-协议响应格式" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.4 协议响应格式"><!--[--><!--]--> 1.4 协议响应格式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/doc/java/redis/12/#_1-5-协议解析及处理" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.5 协议解析及处理"><!--[--><!--]--> 1.5 协议解析及处理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/doc/java/redis/12/#_2-事件处理机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="2. 事件处理机制"><!--[--><!--]--> 2. 事件处理机制 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/doc/java/redis/12/#_2-1-文件事件" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 文件事件"><!--[--><!--]--> 2.1 文件事件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/doc/java/redis/12/#_2-2-时间事件" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 时间事件"><!--[--><!--]--> 2.2 时间事件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/doc/java/redis/12/#_2-3-aeeventloop" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 aeEventLoop"><!--[--><!--]--> 2.3 aeEventLoop <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/doc/java/redis/12/#_2-4-aemain" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.4 aeMain"><!--[--><!--]--> 2.4 aeMain <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/doc/java/redis/12/#_2-5-aeprocessevent" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.5 aeProcessEvent"><!--[--><!--]--> 2.5 aeProcessEvent <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="redis-通讯协议及事件处理机制" tabindex="-1"><a class="header-anchor" href="#redis-通讯协议及事件处理机制" aria-hidden="true">#</a> Redis 通讯协议及事件处理机制</h1><h2 id="_1-通信协议" tabindex="-1"><a class="header-anchor" href="#_1-通信协议" aria-hidden="true">#</a> 1. 通信协议</h2><p>Redis 是单进程单线程的。应用系统和 Redis 通过 Redis 协议(RESP)进行交互。</p><h3 id="_1-1-请求响应模式" tabindex="-1"><a class="header-anchor" href="#_1-1-请求响应模式" aria-hidden="true">#</a> 1.1 请求响应模式</h3><p>Redis 协议位于 TCP 层之上，即客户端和 Redis 实例保持双工的连接。</p><p><img src="/doc/assets/README-1650504096829.fb6421db.png" alt="请求响应模式为双工"></p><h4 id="串行的请求响应模式-ping-pong" tabindex="-1"><a class="header-anchor" href="#串行的请求响应模式-ping-pong" aria-hidden="true">#</a> 串行的请求响应模式(ping-pong)</h4><p>串行化是最简单模式，客户端与服务器端建立长连接。</p><p>连接通过心跳机制检测(ping-pong) ACK 应答</p><p>客户端发送请求，服务端响应，客户端收到响应后，再发起第二个请求，服务器端再响应。</p><p><img src="/doc/assets/README-1650504199408.4e413c0b.png" alt="串行化交互"></p><blockquote><p><code>telnet</code> 和 <code>redis-cli</code> 发出的命令都属于该种模式</p></blockquote><p>特点:</p><ul><li>有问有答</li><li>耗时在网络传输命令</li><li>性能较低</li></ul><h4 id="双工的请求响应模式-pipeline" tabindex="-1"><a class="header-anchor" href="#双工的请求响应模式-pipeline" aria-hidden="true">#</a> 双工的请求响应模式(pipeline)</h4><p>批量请求，批量响应</p><p>请求响应交叉进行，不会混淆(TCP双工)</p><p><img src="/doc/assets/README-1650504314875.2153545c.png" alt="双工请求响应模式"></p><p>pipeline 的作用是将一批命令进行打包，然后发送给服务器，服务器执行完按顺序打包返回。</p><p>通过 pipeline，一次 pipeline(n条命令) = 一次网络时间 + n 次命令时间</p><p>通过 Jedis 可以很方便的使用 pipeline</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">JedisDemo</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">Jedis</span> redis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">&quot;192.168.1.111&quot;</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      redis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span><span class="token string">&quot;12345678&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//授权密码 对应 redis.conf 的 requirepass 密码 </span>
      <span class="token class-name">Pipeline</span> pipe <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">pipelined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         pipe<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;key_&quot;</span> <span class="token operator">+</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 将封装后的 PIPE 一次性发给 Redis </span>
      pipe<span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="原子化的批量请求响应模式-事务" tabindex="-1"><a class="header-anchor" href="#原子化的批量请求响应模式-事务" aria-hidden="true">#</a> 原子化的批量请求响应模式(事务)</h4><p>Redis可以利用事务机制批量执行命令。后面会详细讲解。</p><h4 id="发布订阅模式-pub-sub" tabindex="-1"><a class="header-anchor" href="#发布订阅模式-pub-sub" aria-hidden="true">#</a> 发布订阅模式(pub/sub)</h4><p>发布订阅模式是: 一个客户端触发，多个客户端被动接收，通过服务器中转。后面会详细讲解。</p><h4 id="脚本化的批量执行-lua" tabindex="-1"><a class="header-anchor" href="#脚本化的批量执行-lua" aria-hidden="true">#</a> 脚本化的批量执行(lua)</h4><p>客户端向服务器端提交一个 Lua 脚本，服务器端执行该脚本。后面会详细讲解。</p><h3 id="_1-2-请求数据格式" tabindex="-1"><a class="header-anchor" href="#_1-2-请求数据格式" aria-hidden="true">#</a> 1.2 请求数据格式</h3><p>Redis 客户端与服务器交互采用序列化协议(RESP)。</p><p>请求以字符串数组的形式来表示要执行命令的参数。</p><p>Redis 使用命令特有(command-specific)数据类型作为回复。</p><p>Redis通信协议的主要特点有:</p><ul><li>客户端和服务器通过 TCP 连接来进行数据交互，服务器默认的端口号为 6379 。</li><li>客户端和服务器发送的命令或数据一律以<code> \r\n</code>(CRLF)结尾。</li><li>在这个协议中， 所有发送至 Redis 服务器的参数都是二进制安全(binary safe)的。</li><li>简单，高效，易读。</li></ul><h4 id="内联格式" tabindex="-1"><a class="header-anchor" href="#内联格式" aria-hidden="true">#</a> 内联格式</h4><p>可以使用 <code>telnet</code> 给 Redis 发送命令，首字符为 Redis 命令名的字符，格式为 <code>str1 str2 str3...</code></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost bin<span class="token punctuation">]</span><span class="token comment"># telnet 127.0.0.1 6379</span>
Trying <span class="token number">127.0</span>.0.1<span class="token punctuation">..</span>.
Connected to <span class="token number">127.0</span>.0.1.
Escape character is <span class="token string">&#39;^]&#39;</span><span class="token builtin class-name">.</span>
<span class="token function">ping</span>
+PONG
exists name
:1
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="规范格式-redis-cli-resp" tabindex="-1"><a class="header-anchor" href="#规范格式-redis-cli-resp" aria-hidden="true">#</a> 规范格式(redis-cli) RESP</h4><ol><li>间隔符号; 在 Linux 下是 <code>\r\n</code>，在 Windows 下是 <code>\n</code></li><li>简单字符串 Simple Strings, 以 &quot;+&quot; 加号开头</li><li>错误 Errors, 以 &quot;-&quot; 减号开头</li><li>整数型 Integer， 以 &quot;:&quot; 冒号开头</li><li>大字符串类型 Bulk Strings, 以 &quot;$&quot; 美元符号开头，长度限制 512M</li><li>数组类型 Arrays，以 &quot;*&quot; 星号开头</li></ol><p>用 SET 命令来举例说明 RESP 协议的格式。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>redis<span class="token operator">&gt;</span> SET mykey Hello
<span class="token string">&quot;OK&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>实际发送的请求数据:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$5\r\nHello\r\n
*3
$3
SET
$5
mykey
$5
Hello
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>实际收到的响应数据: <code>+OK\r\n</code></p><h3 id="_1-3-命令处理流程" tabindex="-1"><a class="header-anchor" href="#_1-3-命令处理流程" aria-hidden="true">#</a> 1.3 命令处理流程</h3><p>整个流程包括: 服务器启动监听、接收命令请求并解析、执行命令请求、返回命令回复等。</p><p><img src="/doc/assets/README-1650505203121.28312b4c.png" alt="Redis命令处理流程"></p><h4 id="server-启动时监听-socket" tabindex="-1"><a class="header-anchor" href="#server-启动时监听-socket" aria-hidden="true">#</a> Server 启动时监听 Socket</h4><p>启动调用 initServer 方法:</p><ul><li>创建 eventLoop(事件机制)</li><li>注册时间事件处理器</li><li>注册文件事件(socket)处理器</li><li>监听 Socket 建立连接</li></ul><h4 id="建立client" tabindex="-1"><a class="header-anchor" href="#建立client" aria-hidden="true">#</a> 建立Client</h4><ul><li>redis-cli 建立socket</li><li>redis-server 为每个连接(socket)创建一个 Client 对象</li><li>创建文件事件监听 Socket</li><li>指定事件处理函数</li></ul><h4 id="读取socket数据到输入缓冲区" tabindex="-1"><a class="header-anchor" href="#读取socket数据到输入缓冲区" aria-hidden="true">#</a> 读取socket数据到输入缓冲区</h4><p>从 client 中读取客户端的查询缓冲区内容。</p><h4 id="解析获取命令" tabindex="-1"><a class="header-anchor" href="#解析获取命令" aria-hidden="true">#</a> 解析获取命令</h4><p>将输入缓冲区中的数据解析成对应的命令 判断是单条命令还是多条命令并调用相应的解析器解析</p><h4 id="执行命令" tabindex="-1"><a class="header-anchor" href="#执行命令" aria-hidden="true">#</a> 执行命令</h4><p>解析成功后调用 <code>processCommand</code> 方法执行命令，如下图:</p><p><img src="/doc/assets/README-1650506520886.fd7adf42.png" alt="Redis图解-Redis命令执行流程.png"></p><p>大致分三个部分:</p><ul><li>调用 lookupCommand 方法获得对应的 redisCommand</li><li>检测当前 Redis 是否可以执行该命令</li><li>调用 call 方法真正执行命令</li></ul><h3 id="_1-4-协议响应格式" tabindex="-1"><a class="header-anchor" href="#_1-4-协议响应格式" aria-hidden="true">#</a> 1.4 协议响应格式</h3><h4 id="状态回复" tabindex="-1"><a class="header-anchor" href="#状态回复" aria-hidden="true">#</a> 状态回复</h4><p>对于状态，回复的第一个字节是 “+”</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&quot;+OK&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="错误回复" tabindex="-1"><a class="header-anchor" href="#错误回复" aria-hidden="true">#</a> 错误回复</h4><p>对于错误，回复的第一个字节是 “-”</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>1. -ERR unknown command &#39;foobar&#39;
2. -WRONGTYPE Operation against a key holding the wrong kind of value
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="整数回复" tabindex="-1"><a class="header-anchor" href="#整数回复" aria-hidden="true">#</a> 整数回复</h4><p>对于整数，回复的第一个字节是 “:”</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&quot;:6&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="批量回复" tabindex="-1"><a class="header-anchor" href="#批量回复" aria-hidden="true">#</a> 批量回复</h4><p>对于批量字符串，回复的第一个字节是 “$”</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&quot;$6 foobar&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="多条批量回复" tabindex="-1"><a class="header-anchor" href="#多条批量回复" aria-hidden="true">#</a> 多条批量回复</h4><p>对于多条批量回复(数组)，回复的第一个字节是 “*”</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&quot;*3&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="_1-5-协议解析及处理" tabindex="-1"><a class="header-anchor" href="#_1-5-协议解析及处理" aria-hidden="true">#</a> 1.5 协议解析及处理</h3><p>包括协议解析、调用命令、返回结果。</p><h4 id="协议解析" tabindex="-1"><a class="header-anchor" href="#协议解析" aria-hidden="true">#</a> 协议解析</h4><p>用户在 Redis 客户端键入命令后，Redis-cli 会把命令转化为 RESP 协议格式，然后发送给服务器。服务器再对协议进行解析，分为三个步骤:</p><ol><li>解析命令请求参数数量</li></ol><p>命令请求参数数量的协议格式为 <code>*N\r\n</code> ,其中 N 就是数量，比如:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">set</span> name:1 john
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>我们打开 AOF 文件可以看到协议内容</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>*3(/r/n)
$3(/r/n)
set(/r/n)
$7(/r/n)
name:10(/r/n)
$7(/r/n)
john(/r/n)
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>首字符必须是 <code>*</code>，使用 <code>\r</code> 定位到行尾，之间的数就是参数数量了。</p><ol start="2"><li>循环解析请求参数</li></ol><p>首字符必须是 <code>$</code>，使用 <code>/r</code> 定位到行尾，之间的数是参数的长度，从 <code>/n</code> 后到下一个 <code>$</code> 之间就是参数的值了。</p><p>循环解析直到没有&quot;$&quot;。</p><blockquote><p>第 3 点呢？？？</p></blockquote><h4 id="协议执行" tabindex="-1"><a class="header-anchor" href="#协议执行" aria-hidden="true">#</a> 协议执行</h4><p>协议的执行包括命令的调用和返回结果。</p><p>判断参数个数和取出的参数是否一致。</p><p>RedisServer 解析完命令后,会调用函数 processCommand 处理该命令请求</p><ul><li>quit校验，如果是 <code>quit</code> 命令，直接返回并关闭客户端</li><li>命令语法校验，执行 <code>lookupCommand</code>，查找命令(set)，如果不存在则返回: “unknown command” 错误。</li><li>参数数目校验，参数数目和解析出来的参数个数要匹配，如果不匹配则返回: “wrong number of arguments” 错误。</li><li>此外还有权限校验，最大内存校验，集群校验，持久化校验等等。</li></ul><p>校验成功后，会调用 <code>call</code> 函数执行命令，并记录命令执行时间和调用次数。如果执行命令时间过长，还要记录慢查询日志。</p><p>执行命令后返回结果的类型不同则协议格式也不同，分为5类: 状态回复、错误回复、整数回复、批量回复、多条批量回复。</p><h2 id="_2-事件处理机制" tabindex="-1"><a class="header-anchor" href="#_2-事件处理机制" aria-hidden="true">#</a> 2. 事件处理机制</h2><p>Redis 服务器是典型的事件驱动系统。</p><blockquote><p>MVC : java 上层调下层</p><p>事件驱动: js</p></blockquote><p>Redis 将事件分为两大类: 文件事件和时间事件。</p><h3 id="_2-1-文件事件" tabindex="-1"><a class="header-anchor" href="#_2-1-文件事件" aria-hidden="true">#</a> 2.1 文件事件</h3><p>文件事件即 Socket 的读写事件，也就是 IO 事件。 file descriptor (文件描述符)</p><p>客户端的连接、命令请求、数据回复、连接断开</p><h4 id="socket" tabindex="-1"><a class="header-anchor" href="#socket" aria-hidden="true">#</a> socket</h4><p>套接字(socket)是一个抽象层，应用程序可以通过它发送或接收数据。</p><h4 id="reactor" tabindex="-1"><a class="header-anchor" href="#reactor" aria-hidden="true">#</a> Reactor</h4><p>Redis 事件处理机制采用单线程的 Reactor 模式，属于 I/O 多路复用的一种常见模式。</p><p>IO 多路复用(I/O multiplexing)指的通过单个线程管理多个 Socket。</p><p>Reactor pattern(反应器设计模式)是一种为处理并发服务请求，并将请求提交到一个或者多个服务处理程序的事件设计模式。</p><p>Reactor 模式是事件驱动的</p><p>有一个或多个并发输入源(文件事件)</p><p>有一个 Service Handler</p><p>有多个 Request Handlers</p><p>这个 Service Handler 会同步的将输入的请求(Event)多路复用的分发给相应的 Request Handler</p><p><img src="/doc/assets/README-1650590916627.16b52ed3.png" alt="Reactor模型"></p><p><img src="/doc/assets/README-1650590961671.b9912a4b.png" alt="Reactor模型结构"></p><ul><li>Handle: I/O 操作的基本文件句柄，在 Linux 下就是fd(文件描述符)</li><li>Synchronous Event Demultiplexer: 同步事件分离器，阻塞等待 Handles 中的事件发生。(系统)</li><li>Reactor: 事件分派器，负责事件的注册，删除以及对所有注册到事件分派器的事件进行监控， 当事件发生时会调用 Event Handler 接口来处理事件。</li><li>Event Handler: 事件处理器接口，这里需要 Concrete Event Handler 来实现该接口</li><li>Concrete Event Handler: 真实的事件处理器，通常都是绑定了一个handle，实现对可读事件进行读取或对可写事件进行写入的操作。</li></ul><p><img src="/doc/assets/README-1650591150766.7729d99b.png" alt="业务流程及时序图"></p><ul><li>主程序向事件分派器(Reactor)注册要监听的事件</li><li>Reactor 调用 OS 提供的事件处理分离器，监听事件(wait)</li><li>当有事件产生时，Reactor 将事件派给相应的处理器来处理 <code>handle_event()</code></li></ul><h4 id="_4种io多路复用模型与选择" tabindex="-1"><a class="header-anchor" href="#_4种io多路复用模型与选择" aria-hidden="true">#</a> 4种IO多路复用模型与选择</h4><p>select，poll，epoll、kqueue 都是IO多路复用的机制。</p><p>I/O 多路复用就是通过一种机制，一个进程可以监视多个描述符(socket)，一旦某个描述符就绪(一般是读就绪或者写就绪)，能够通知程序进行相应的读写操作。</p><h5 id="select" tabindex="-1"><a class="header-anchor" href="#select" aria-hidden="true">#</a> select</h5><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">select</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>select 函数监视的文件描述符分3类，分别是:</p><ul><li><code>writefds</code></li><li><code>readfds</code></li><li><code>exceptfds</code></li></ul><p>调用后 <code>select</code> 函数会阻塞，直到有描述符就绪(有数据可读、可写、或者有except)，或者超时(timeout指定等待时间，如果立即返回设为null即可)，函数返回。 当 <code>select</code> 函数返回后，可以通过遍历 <code>fd</code> 列表，来找到就绪的描述符。</p><p><strong>优点</strong></p><p><code>select</code> 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。</p><p>windows linux ...</p><p><strong>缺点</strong></p><p>单个进程打开的文件描述是有一定限制的，它由 <code>FD_SETSIZE</code> 设置，默认值是 1024，采用数组存储另外在检查数组中是否有文件描述需要读写时，采用的是线性扫描的方法， 即不管这些 socket 是不是活跃的，都轮询一遍，所以效率比较低。</p><h5 id="poll" tabindex="-1"><a class="header-anchor" href="#poll" aria-hidden="true">#</a> poll</h5><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">poll</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> fd<span class="token punctuation">;</span> <span class="token comment">// 文件描述符</span>
   <span class="token keyword">short</span> events<span class="token punctuation">;</span> <span class="token comment">// 要监视的事件 </span>
   <span class="token keyword">short</span> revents<span class="token punctuation">;</span> <span class="token comment">// 实际发生的事件</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><code>poll</code> 使用一个 <code>pollfd</code> 的指针实现，<code>pollfd</code> 结构包含了要监视的 event 和发生的 event，不再使用 <code>select&quot;参数-值&quot;</code> 传递的方式。</p><ul><li>优点: 采样链表的形式存储，它监听的描述符数量没有限制，可以超过 select 默认限制的 1024 大小</li><li>缺点: 另外在检查链表中是否有文件描述需要读写时，采用的是线性扫描的方法，即不管这些 socket 是不是活跃的，都轮询一遍，所以效率比较低。</li></ul><h5 id="epoll" tabindex="-1"><a class="header-anchor" href="#epoll" aria-hidden="true">#</a> epoll</h5><p>epoll 是在 Linux2.6 内核中提出的，是之前的 select 和 poll 的增强版本。</p><p>相对于 select 和 poll 来说，epoll 更加灵活，没有描述符限制。</p><p>epoll 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>创建一个 epoll 的句柄。自从 Linux 2.6.8 之后，<code>size</code> 参数是被忽略的。需要注意的是，当创建好 epoll 句柄后，它就是会占用一个 fd 值，在 Linux 下如果查看 <code>/proc/进程id/fd/</code>，是能够看到这个 fd 的， 所以在使用完 epoll 后，必须调用 <code>close()</code> 关闭，否则可能导致 fd 被耗尽。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>poll</code> 的事件注册函数，它不同于 <code>select()</code> 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</p><ul><li>第一个参数是 <code>epoll_create()</code> 的返回值。</li><li>第二个参数表示动作，用三个宏来表示: <code>EPOLL_CTL_ADD</code>: 注册新的 fd 到 epfd 中; <code>EPOLL_CTL_MOD</code>: 修改已经注册的fd的监听事件; <code>EPOLL_CTL_DEL</code>: 从 epfd 中删除一个 fd;</li><li>第三个参数是需要监听的 fd。</li><li>第四个参数是告诉内核需要监听什么事</li></ul><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>等待内核返回的可读写事件，最多返回 <code>maxevents</code> 个事件。</p><p>优点: <code>epoll</code> 没有最大并发连接的限制，上限是最大可以打开文件的数目。举个例子,在 1GB 内存的机器上大约是 10 万左右。</p><p>效率提升， epoll 最大的优点就在于它只管你「活跃」的连接 ，而跟连接总数无关，因此在实际的网络环境 中， epoll 的效率就会远远高于 select 和 poll。</p><p>epoll 使用了共享内存，不用做内存拷贝。</p><h5 id="kqueue" tabindex="-1"><a class="header-anchor" href="#kqueue" aria-hidden="true">#</a> kqueue</h5><p>kqueue 是 unix 下的一个 IO 多路复用库。最初是 2000 年 Jonathan Lemon 在 FreeBSD 系统上开发的一个高性能的事件通知接口。 注册一批 socket 描述符到 kqueue 以后，当其中的描述符状态发生变化时，kqueue 将一次性通知应用程序哪些描述符可读、可写或出错了。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">kevent</span> <span class="token punctuation">{</span>
   <span class="token class-name">uintptr_t</span>   ident<span class="token punctuation">;</span>   <span class="token comment">// 是事件唯一的 key，在 socket() 使用中，它是 socket 的 fd 句柄</span>
   <span class="token class-name">int16_t</span>     filter<span class="token punctuation">;</span>  <span class="token comment">// 是事件的类型(EVFILT_READ socket 可读事件, EVFILT_WRITE  socket 可写事件)</span>
   <span class="token class-name">uint16_t</span>    flags<span class="token punctuation">;</span>   <span class="token comment">// 操作方式</span>
   <span class="token class-name">uint32_t</span>    fflags<span class="token punctuation">;</span>  <span class="token comment">//</span>
   <span class="token class-name">intptr_t</span>    data<span class="token punctuation">;</span>    <span class="token comment">// 数据长度</span>
   <span class="token keyword">void</span>        <span class="token operator">*</span>udata<span class="token punctuation">;</span>  <span class="token comment">// 数据</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>优点: 能处理大量数据，性能较高</p><h4 id="文件事件分派器" tabindex="-1"><a class="header-anchor" href="#文件事件分派器" aria-hidden="true">#</a> 文件事件分派器</h4><p>在 Redis 中，对文件事件的处理采用了 Reactor 模型。采用的是 epoll 的实现方式。</p><p><img src="/doc/assets/README-1650592425682.4455a8f0.png" alt="文件事件分派器"></p><p>Redis 在主循环中统一处理文件事件和时间事件，信号事件则由专门的 Handler 来处理。</p><p>主循环:</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   eventLoop<span class="token operator">-&gt;</span>stop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>eventLoop<span class="token operator">-&gt;</span>stop<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//循环监听事件</span>
      <span class="token comment">// 阻塞之前的处理</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>beforesleep <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
         eventLoop<span class="token operator">-&gt;</span><span class="token function">beforesleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 事件处理，第二个参数决定处理哪类事件</span>
      <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> AE_ALL_EVENTS<span class="token operator">|</span>AE_CALL_AFTER_SLEEP<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="事件处理器" tabindex="-1"><a class="header-anchor" href="#事件处理器" aria-hidden="true">#</a> 事件处理器</h4><h5 id="连接处理函数-accepttcphandler" tabindex="-1"><a class="header-anchor" href="#连接处理函数-accepttcphandler" aria-hidden="true">#</a> 连接处理函数 acceptTCPHandler</h5><p>当客户端向 Redis 建立 socket 时，aeEventLoop 会调用 acceptTcpHandler 处理函数，服务器会为每个链接创建一个 Client 对象， 并创建相应文件事件来监听 socket 的可读事件，并指定事件处理函数。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// 当客户端建立链接时进行的eventloop处理函数 networking.c</span>
<span class="token keyword">void</span> <span class="token function">acceptTcpHandler</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token comment">// 层层调用，最后在 anet.c 中 anetGenericAccept 方法中调用 socket 的 accept 方法 </span>
   cfd <span class="token operator">=</span> <span class="token function">anetTcpAccept</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>neterr<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> cip<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cip<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>cport<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>cfd <span class="token operator">==</span> ANET_ERR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">!=</span> EWOULDBLOCK<span class="token punctuation">)</span>
            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span>
                <span class="token string">&quot;Accepting client connection: %s&quot;</span><span class="token punctuation">,</span> server<span class="token punctuation">.</span>neterr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   
   <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_VERBOSE<span class="token punctuation">,</span><span class="token string">&quot;Accepted %s:%d&quot;</span><span class="token punctuation">,</span> cip<span class="token punctuation">,</span> cport<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   <span class="token comment">/**
    * 进行socket 建立连接后的处理
    */</span>
    <span class="token function">acceptCommonHandler</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>cip<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h5 id="请求处理函数-readqueryfromclient" tabindex="-1"><a class="header-anchor" href="#请求处理函数-readqueryfromclient" aria-hidden="true">#</a> 请求处理函数 readQueryFromClient</h5><p>当客户端通过 socket 发送来数据后，Redis 会调用 <code>readQueryFromClient</code> 方法, <code>readQueryFromClient</code> 方法会调用 <code>read</code> 方法从 socket 中读取数据到输入缓冲区中， 然后判断其大小是否大于系统设置的 <code>client_max_querybuf_len</code>，如果大于，则向 Redis 返回错误信息，并关闭 client。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">// 处理从client中读取客户端的输入缓冲区内容。</span>
<span class="token keyword">void</span> <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>el<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token punctuation">(</span>client<span class="token operator">*</span><span class="token punctuation">)</span> privdata<span class="token punctuation">;</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf_peak <span class="token operator">&lt;</span> qblen<span class="token punctuation">)</span> c<span class="token operator">-&gt;</span>querybuf_peak <span class="token operator">=</span> qblen<span class="token punctuation">;</span>
   c<span class="token operator">-&gt;</span>querybuf <span class="token operator">=</span> <span class="token function">sdsMakeRoomFor</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">// 从 fd 对应的socket中读取到 client 中的 querybuf 输入缓冲区</span>
   nread <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> c<span class="token operator">-&gt;</span>querybuf<span class="token operator">+</span>qblen<span class="token punctuation">,</span> readlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token comment">// 如果大于系统配置的最大客户端缓存区大小，也就是配置文件中的client-query-buffer-limit</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sdslen</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">)</span> <span class="token operator">&gt;</span> server<span class="token punctuation">.</span>client_max_querybuf_len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      sds ci <span class="token operator">=</span> <span class="token function">catClientInfoString</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span> bytes <span class="token operator">=</span> <span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 返回错误信息，并且关闭client</span>
      bytes <span class="token operator">=</span> <span class="token function">sdscatrepr</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>querybuf<span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">&quot;Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)&quot;</span><span class="token punctuation">,</span> ci<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sdsfree</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sdsfree</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">freeClient</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_MASTER<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// processInputBuffer 处理输入缓冲区</span>
      <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果client是master的连接</span>
      <span class="token class-name">size_t</span> prev_offset <span class="token operator">=</span> c<span class="token operator">-&gt;</span>reploff<span class="token punctuation">;</span> <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 判断是否同步偏移量发生变化，则通知到后续的slave size_t applied = c-&gt;reploff - prev_offset;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>applied<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token function">replicationFeedSlavesFromMasterStream</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slaves<span class="token punctuation">,</span> c<span class="token operator">-&gt;</span>pending_querybuf<span class="token punctuation">,</span> applied<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">sdsrange</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>pending_querybuf<span class="token punctuation">,</span>applied<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
      <span class="token punctuation">}</span> 
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h5 id="命令回复处理器-sendreplytoclient" tabindex="-1"><a class="header-anchor" href="#命令回复处理器-sendreplytoclient" aria-hidden="true">#</a> 命令回复处理器 sendReplyToClient</h5><p><code>sendReplyToClient</code> 函数是 Redis 的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端。</p><ol><li>将 <code>outbuf</code> 内容写入到套接字描述符并传输到客户端</li><li><code>aeDeleteFileEvent</code> 用于删除文件写事件</li></ol><h3 id="_2-2-时间事件" tabindex="-1"><a class="header-anchor" href="#_2-2-时间事件" aria-hidden="true">#</a> 2.2 时间事件</h3><p>时间事件分为定时事件与周期事件。</p><p>一个时间事件主要由以下三个属性组成:</p><ul><li>id (全局唯一id)</li><li>when (毫秒时间戳，记录了时间事件的到达时间)</li><li>timeProc (时间事件处理器，当时间到达时，Redis就会调用相应的处理器来处理事件)</li></ul><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">/* Time event structure
 *
* 时间事件结构
*/</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token punctuation">{</span>
   <span class="token comment">// 时间事件的唯一标识符</span>
   <span class="token keyword">long</span> id<span class="token punctuation">;</span> <span class="token comment">/* time event identifier. */</span>
   <span class="token comment">// 事件的到达时间，存贮的是UNIX的时间戳</span>
   <span class="token keyword">long</span> when_sec<span class="token punctuation">;</span> <span class="token comment">/* seconds */</span>
   <span class="token keyword">long</span> when_ms<span class="token punctuation">;</span> <span class="token comment">/* milliseconds */</span>
   <span class="token comment">// 事件处理函数，当到达指定时间后调用该函数处理对应的问题</span>
   aeTimeProc <span class="token operator">*</span>timeProc<span class="token punctuation">;</span>
   <span class="token comment">// 事件释放函数</span>
   aeEventFinalizerProc <span class="token operator">*</span>finalizerProc<span class="token punctuation">;</span>
   <span class="token comment">// 多路复用库的私有数据</span>
   <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span>
   <span class="token comment">// 指向下个时间事件结构，形成链表</span>
   <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> aeTimeEvent<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h4 id="servercron" tabindex="-1"><a class="header-anchor" href="#servercron" aria-hidden="true">#</a> serverCron</h4><p>时间事件的最主要的应用是在 Redis 服务器需要对自身的资源与配置进行定期的调整，从而确保服务器的长久运行，这些操作由 <code>redis.c</code> 中的 <code>serverCron</code> 函数实现。 该时间事件主要进行以下操作:</p><ol><li>更新 Redis服务器各类统计信息，包括时间、内存占用、数据库占用等情况。</li><li>清理数据库中的过期键值对。</li><li>关闭和清理连接失败的客户端。</li><li>尝试进行aof和rdb持久化操作。</li><li>如果服务器是主服务器，会定期将数据向从服务器做同步操作。</li><li>如果处于集群模式，对集群定期进行同步与连接测试操作。</li></ol><p>Redis 服务器开启后，就会周期性执行此函数，直到 Redis 服务器关闭为止。默认每秒执行 10 次，平均 100 毫秒执行一次， 可以在 Redis 配置文件的 hz 选项，调整该函数每秒执行的次数。</p><p><strong>server.hz</strong></p><p>serverCron 在一秒内执行的次数， 在 <code>redis/conf</code> 中可以配置</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>hz <span class="token number">10</span> <span class="token comment">#100毫秒一次</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>比如: <code>server.hz</code> 是100，也就是 serverCron 的执行间隔是10ms</p><p><strong>run_with_period</strong></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#define run_with_period(_ms_) \</span>
<span class="token keyword">if</span> <span class="token variable"><span class="token punctuation">((</span>_ms_ <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token operator">/</span>server.hz<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>server.cronloops<span class="token operator">%</span><span class="token punctuation">((</span>_ms_<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token operator">/</span>server.hz<span class="token punctuation">))</span></span><span class="token punctuation">))</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>定时任务执行都是在 10 毫秒的基础上定时处理自己的任务(<code>run_with_period(ms)</code>)，即调用 <code>run_with_period(ms)</code> 来确定自己是否需要执行。返回1表示执行。</p><blockquote><p>&quot;ms&quot; 是指多长时间执行一次，单位是毫秒。</p></blockquote><p>假如有一些任务需要每 500ms 执行一次，就可以在 serverCron 中用 <code>run_with_period(500)</code> 把每 500ms 需要执行一次的工作控制起来。</p><h4 id="定时事件" tabindex="-1"><a class="header-anchor" href="#定时事件" aria-hidden="true">#</a> 定时事件</h4><p>定时事件: 让一段程序在指定的时间之后执行一次。</p><p><code>aeTimeProc</code>(时间处理器)的返回值是 <code>AE_NOMORE</code></p><p>该事件在达到后删除，之后不会再重复。</p><h4 id="周期性事件" tabindex="-1"><a class="header-anchor" href="#周期性事件" aria-hidden="true">#</a> 周期性事件</h4><p>周期性事件: 让一段程序每隔指定时间就执行一次。</p><p><code>aeTimeProc</code> (时间处理器)的返回值不是 <code>AE_NOMORE</code></p><p>当一个时间事件到达后，服务器会根据时间处理器的返回值，对时间事件的 <code>when</code> 属性进行更新，让这个事件在一段时间后再次达到。</p><p><em>serverCron 就是一个典型的周期性事件。</em></p><h3 id="_2-3-aeeventloop" tabindex="-1"><a class="header-anchor" href="#_2-3-aeeventloop" aria-hidden="true">#</a> 2.3 aeEventLoop</h3><p>aeEventLoop 是整个事件驱动的核心，Redis 自己的事件处理机制。</p><p>它管理着文件事件表和时间事件列表，不断地循环处理着就绪的文件事件和到期的时间事件。</p><p><img src="/doc/assets/README-1650726052807.eef10ac1.png" alt="aeEventLoop流程"></p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token punctuation">{</span>
   <span class="token comment">// 最大文件描述符的值</span>
   <span class="token keyword">int</span> maxfd<span class="token punctuation">;</span> <span class="token comment">/* highest file descriptor currently registered */</span> 
   <span class="token comment">// 文件描述符的最大监听数</span>
   <span class="token keyword">int</span> setsize<span class="token punctuation">;</span> <span class="token comment">/* max number of file descriptors tracked */</span> 
   <span class="token comment">// 用于生成时间事件的唯一标识id</span>
   <span class="token keyword">long</span> <span class="token keyword">long</span> timeEventNextId<span class="token punctuation">;</span>
   <span class="token comment">// 用于检测系统时间是否变更(判断标准 now&lt;lastTime)</span>
   <span class="token class-name">time_t</span> lastTime<span class="token punctuation">;</span> <span class="token comment">/* Used to detect system clock skew */</span> 
   <span class="token comment">// 注册的文件事件</span>
   aeFileEvent <span class="token operator">*</span>events<span class="token punctuation">;</span> <span class="token comment">/* Registered events */</span>
   <span class="token comment">// 已就绪的事件</span>
   aeFiredEvent <span class="token operator">*</span>fired<span class="token punctuation">;</span> <span class="token comment">/* Fired events */</span>
   <span class="token comment">// 注册要使用的时间事件</span>
   aeTimeEvent <span class="token operator">*</span>timeEventHead<span class="token punctuation">;</span>
   <span class="token comment">// 停止标志，1表示停止</span>
   <span class="token keyword">int</span> stop<span class="token punctuation">;</span>
   <span class="token comment">// 这个是处理底层特定API的数据，对于epoll来说，该结构体包含了epoll fd和epoll_event void *apidata; /* This is used for polling API specific data */ </span>
   <span class="token comment">// 在调用processEvent前(即如果没有事件则睡眠)，调用该处理函数</span>
   aeBeforeSleepProc <span class="token operator">*</span>beforesleep<span class="token punctuation">;</span>
   <span class="token comment">// 在调用aeApiPoll后，调用该函数</span>
   aeBeforeSleepProc <span class="token operator">*</span>aftersleep<span class="token punctuation">;</span>
<span class="token punctuation">}</span> aeEventLoop<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h4 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化" aria-hidden="true">#</a> 初始化</h4><p>Redis 服务端在其初始化函数 <code>initServer</code> 中，会创建事件管理器 <code>aeEventLoop</code> 对象。</p><p>函数 <code>aeCreateEventLoop</code> 将创建一个事件管理器，主要是初始化 <code>aeEventLoop</code> 的各个属性值， 比如 <code>events</code>、 <code>fired</code>、 <code>timeEventHead</code> 和 <code>apidata</code></p><ul><li>首先创建 aeEventLoop 对象。</li><li>初始化注册的文件事件表、就绪文件事件表。<code>events</code> 指针指向注册的文件事件表、<code>fired</code> 指针指向就绪文件事件表。表的内容在后面添加具体事件时进行初变更。</li><li>初始化时间事件列表，设置 <code>timeEventHead</code> 和 <code>timeEventNextId</code> 属性。</li><li>调用 <code>aeApiCreate</code> 函数创建 <code>epoll</code> 实例，并初始化 <code>apidata</code> 。</li></ul><h4 id="stop" tabindex="-1"><a class="header-anchor" href="#stop" aria-hidden="true">#</a> stop</h4><p>停止标志，1 表示停止，初始化为 0。</p><h4 id="文件事件" tabindex="-1"><a class="header-anchor" href="#文件事件" aria-hidden="true">#</a> 文件事件</h4><p><code>events</code>, <code>fired</code>, <code>apidata</code></p><p><code>aeFileEvent</code> 结构体为已经注册并需要监听的事件的结构体。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeFileEvent</span> <span class="token punctuation">{</span>
   <span class="token comment">// 监听事件类型掩码，</span>
   <span class="token comment">// 值可以是 AE_READABLE 或 AE_WRITABLE ，</span>
   <span class="token comment">// 或者 AE_READABLE | AE_WRITABLE</span>
   <span class="token keyword">int</span> mask<span class="token punctuation">;</span> <span class="token comment">/* one of AE_(READABLE|WRITABLE) */</span>
   
   <span class="token comment">// 读事件处理器 </span>
   aeFileProc <span class="token operator">*</span>rfileProc<span class="token punctuation">;</span>
   
   <span class="token comment">// 写事件处理器 </span>
   aeFileProc <span class="token operator">*</span>wfileProc<span class="token punctuation">;</span>
   
   <span class="token comment">// 多路复用库的私有数据 </span>
   <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span>
   
<span class="token punctuation">}</span> aeFileEvent<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><code>aeFiredEvent</code>: 已就绪的文件事件</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeFiredEvent</span> <span class="token punctuation">{</span>
   <span class="token comment">// 已就绪文件描述符</span>
   <span class="token keyword">int</span> fd<span class="token punctuation">;</span>
   
   <span class="token comment">// 事件类型掩码，</span>
   <span class="token comment">// 值可以是 AE_READABLE 或 AE_WRITABLE </span>
   <span class="token comment">// 或者是两者的或</span>
   <span class="token keyword">int</span> mask<span class="token punctuation">;</span>
<span class="token punctuation">}</span> aeFiredEvent<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>void *apidata</code>: 在 ae 创建的时候，会被赋值为 <code>aeApiState</code> 结构体，结构体的定义如下:</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeApiState</span> <span class="token punctuation">{</span> 
   <span class="token comment">// epoll_event 实例描述符</span>
   <span class="token keyword">int</span> epfd<span class="token punctuation">;</span>
   
   <span class="token comment">// 事件槽</span>
   <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">;</span>
   
<span class="token punctuation">}</span> aeApiState<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这个结构体是为了 epoll 所准备的数据结构。Redis 可以选择不同的 I/O 多路复用方法。因此 <code>apidata</code> 是个 <code>void</code> 类型，根据不同的 io 多路复用库来选择不同的实现。</p><p><code>ae.c</code> 里面使用如下的方式来决定系统使用的机制:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#ifdef HAVE_EVPORT</span>
<span class="token comment">#include &quot;ae_evport.c&quot;</span>
<span class="token comment">#else</span>
    <span class="token comment">#ifdef HAVE_EPOLL</span>
    <span class="token comment">#include &quot;ae_epoll.c&quot;</span>
    <span class="token comment">#else</span>
        <span class="token comment">#ifdef HAVE_KQUEUE</span>
        <span class="token comment">#include &quot;ae_kqueue.c&quot;</span>
        <span class="token comment">#else</span>
        <span class="token comment">#include &quot;ae_select.c&quot;</span>
        <span class="token comment">#endif</span>
    <span class="token comment">#endif</span>
<span class="token comment">#endif</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="时间事件" tabindex="-1"><a class="header-anchor" href="#时间事件" aria-hidden="true">#</a> 时间事件</h4><p><code>timeEventHead</code>, <code>beforesleep</code>, <code>aftersleep</code></p><p><code>aeTimeEvent</code> 结构体为时间事件，Redis 将所有时间事件都放在一个无序链表中，每次 Redis 会遍历整个链表， 查找所有已经到达的时间事件，并且调用相应的事件处理器。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token punctuation">{</span> 
   <span class="token comment">/* 全局唯一ID */</span>
   <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span> <span class="token comment">/* time event identifier. */</span> 
   <span class="token comment">/* 秒精确的UNIX时间戳，记录时间事件到达的时间*/</span> 
   <span class="token keyword">long</span> when_sec<span class="token punctuation">;</span> <span class="token comment">/* seconds */</span>
   <span class="token comment">/* 毫秒精确的UNIX时间戳，记录时间事件到达的时间*/</span> 
   <span class="token keyword">long</span> when_ms<span class="token punctuation">;</span> <span class="token comment">/* milliseconds */</span>
   <span class="token comment">/* 时间处理器 */</span>
   aeTimeProc <span class="token operator">*</span>timeProc<span class="token punctuation">;</span>
   <span class="token comment">/* 事件结束回调函数，析构一些资源*/</span> 
   aeEventFinalizerProc <span class="token operator">*</span>finalizerProc<span class="token punctuation">;</span> 
   <span class="token comment">/* 私有数据 */</span>
   <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span>
   <span class="token comment">/* 前驱节点 */</span>
   <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
   <span class="token comment">/* 后继节点 */</span>
   <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> aeTimeEvent<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p><code>beforesleep</code> 对象是一个回调函数，在 redis-server 初始化时已经设置好了。</p><p>功能:</p><ul><li>检测集群状态</li><li>随机释放已过期的键</li><li>在数据同步复制阶段取消客户端的阻塞</li><li>处理输入数据，并且同步副本信息</li><li>处理非阻塞的客户端请求</li><li>AOF 持久化存储策略，类似于 mysql 的 bin log</li><li>使用挂起的输出缓冲区处理写入</li></ul><p><code>aftersleep</code> 对象是一个回调函数，在 IO 多路复用与 IO 事件处理之间被调用。</p><h3 id="_2-4-aemain" tabindex="-1"><a class="header-anchor" href="#_2-4-aemain" aria-hidden="true">#</a> 2.4 aeMain</h3><p>aeMain 函数其实就是一个封装的 <code>while</code> 循环，循环中的代码会一直运行直到 <code>eventLoop</code> 的 <code>stop</code> 被设置为 1(true)。 它会不停尝试调用 <code>aeProcessEvents</code> 对可能存在的多种事件进行处理，而 <code>aeProcessEvents</code> 就是实际用于处理事件的函数。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    eventLoop<span class="token operator">-&gt;</span>stop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>eventLoop<span class="token operator">-&gt;</span>stop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>beforesleep <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            eventLoop<span class="token operator">-&gt;</span><span class="token function">beforesleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> AE_ALL_EVENTS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>aemain</code> 函数中，首先调用 <code>Beforesleep</code>。这个方法在 Redis 每次进入 <code>sleep/wait</code> 去等待监听的端口发生 I/O 事件之前被调用。 当有事件发生时，调用 <code>aeProcessEvent</code>进行处理。</p><h3 id="_2-5-aeprocessevent" tabindex="-1"><a class="header-anchor" href="#_2-5-aeprocessevent" aria-hidden="true">#</a> 2.5 aeProcessEvent</h3><p>首先计算距离当前时间最近的时间事件，以此计算一个超时时间;</p><p>然后调用 <code>aeApiPoll</code> 函数去等待底层的 I/O 多路复用事件就绪;</p><p><code>aeApiPoll</code> 函数返回之后，会处理所有已经产生文件事件和已经达到的时间事件。</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><em>计算最早时间事件的执行时间，获取文件时间可执行时间</em></p><p>aeSearchNearestTimer</p><p>aeProcessEvents 都会先计算最近的时间事件发生所需要等待的时间，然后调用 aeApiPoll 方法在这段时间中等待事件的发生， 在这段时间中如果发生了文件事件，就会优先处理文件事件，否则就会一直等待，直到最近的时间事件需要触发。</p><p><em>堵塞等待文件事件产生</em></p><p>aeApiPoll 用到了 epoll，select，kqueue 和 evport 四种实现方式。</p><p><em>处理文件事件</em></p><p><code>rfileProc</code> 和 <code>wfileProc</code> 就是在文件事件被创建时传入的函数指针</p><ul><li>处理读事件: <code>rfileProc</code></li><li>处理写事件: <code>wfileProc</code></li></ul><p><em>处理时间事件</em></p><p>processTimeEvents 取得当前时间，循环时间事件链表，如果当前时间 &gt;= 预订执行时间，则执行时间处理函数。</p><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/faustine8/doc/edit/main/docs/java/redis/12/README.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑"><!--[--><!--]--> 在 GitHub 上编辑 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">更新时间: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: faustine923@icloud.com">mujunlin</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/doc/java/redis/11/" class="" aria-label="Redis 缓存过期和淘汰策略"><!--[--><!--]--> Redis 缓存过期和淘汰策略 <!--[--><!--]--></a></span><span class="next"><a href="/doc/java/redis/13/" class="" aria-label="Redis 通讯协议及事件处理机制"><!--[--><!--]--> Redis 通讯协议及事件处理机制 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/doc/assets/app.40df414d.js" defer></script>
  </body>
</html>
