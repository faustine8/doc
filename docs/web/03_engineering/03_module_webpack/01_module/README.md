# 模块化开发

当下最重要的前端开发范式

模块化是最主流的代码组织方式，他把复杂代码按照功能的不同划分为不同的模块，单独维护的方式提高了开发效率、降低维护成本。

「模块化」只是思想，并不包含具体的实现。

- 模块化演变过程
- 模块化规范
- 常用的模块化打包工具
- 基于模块化工具构建现代 Web 应用
- 打包工具的优化技巧

## 1. 模块化演变过程

### 1.1 Stage1-文件划分方式

具体做法就是将每个功能，各⾃单独放到不同的⽂件中，约定每个⽂件就是⼀个独⽴的模块，使⽤某个模块就是将这个⽂件引⼊到⻚⾯中，
然后直接调⽤⽂件中的成员(变量/函数)。

缺点：

- 污染全局变量
- 命名冲突问题
- 依赖关系不好管理

早期模块化完全依靠约定

### 1.2 Stage2-命名空间方式

在第一阶段基础上，通过将每个模块包裹成为一个全局对象的方式去实现。

虽然命名空间减少了命名冲突问题，但是这种方式仍然没有私有空间，所以模块成员仍然可以在外部被访问、被修改。

另外模块间的依赖关系问题也没有得到解决。

### 1.3 Stage3-IIFE

具体做法就是将模块中每一个成员，都放在一个函数提供的私有作用域当中。对于需要暴露给外部的成员，通过挂载到全局对象上的方式去实现。

这种方式实现了私有成员的概念。(私有成员只能通过内部成员通过闭包的方式访问，在外部无法使用，这样就确保了私有变量的安全)

还可以通过自调用函数的参数，实现依赖的声明。这样使得模块间的依赖关系更加明显。

---

这就是早期在没有模块化规范的时候，对模块化的落地实现方式。

---

### 1.4 模块化规范出现

模块化标准 + 模块加载器

#### 1.4.1 CommonJS 规范

- 一个文件就是一个模块
- 每个模块都有单独的作用域
- 通过 `module.exports` 导出成员
- 通过 `require` 函数载入模块

CommonJS 是以同步模式加载模块。适合 NodeJS 但是不适合浏览器。

> 为什么浏览器端不适合？ 因为他是同步加载模式的，NodeJS 只在启动的时候加载，运行过程中只是使用；
> 如果用于浏览器的话，每次打开新的页面都会导致大量的同步加载请求出现。

因此，结合浏览器的特点重新设计了一个模块化规范 AMD。

### 1.4.2 AMD

Asynchronous Module Definition(异步模块定义规范)。

同时期还推出了一个非常出名的库：Require.js。它实现了 AMD 规范，同时它又是一个非常强大的模块加载器。

约定的语法：

```js
// 定义一个模块
// 使用 define() 函数去定义。
// define() 函数支持三个参数：1.模块的名字，后期加载模块的时候需要用到；2.数组，用于声明模块的依赖项; 
// 3.函数，函数的参数与前面的依赖项一一对应，每一项分别为依赖项导出的成员
define('模块名字', ['声明模块依赖项', 'jquery'], function (module1, $) {
    return '值' // 通过 return 导出模块成员
});

// 加载一个模块。 require() 函数用于自动加载模块，用法与 define 函数类似；
require(['模块名称'], function (module1) { // module1: 模块变量引⽤
    // 代码 
});
// require 仅用于加载模块，define 用于定义模块的
```

> 目前绝大多数第三方库都支持 AMD 规范。

- 但是 AMD 使用起来相对复杂。
- 模块 JS 文件请求频繁。

> 只能算是前端模块化道路上妥协的实现方式。

---

此外，同期推出的还有 Sea.js 库 + CMD 规范，在使用上和 CommonJS 类似。

## 2. 模块化标准规范

> 模块化的最佳实现

- NodeJS => CommonJS
- 浏览器  => ES Modules

### 2.1 ES Module

#### 2.1.1 基本特性

通过给 `script` 标签添加 `type=module` 的属性，就可以以 ES Module 的标准执行其中的 JS 代码了。

1. ESM ⾃动采⽤严格模式，忽略 `'use strict'`
2. 每个 ES Module 都是运⾏在单独的私有作⽤域中
3. ESM 是通过 CORS 的⽅式请求外部 JS 模块的
4. ESM 的 `script` 标签会延迟执⾏脚本

#### 2.1.2 导入和导出

`export` 导出, `import` 引⼊

```js
// ./module.js
const foo = 'es modules'
export {foo}
```

```js
// ./app.js
import {foo} from './module.js'
console.log(foo) // => es modules
```

```shell
# 监视文件变化热加载的服务器
browser-sync . --files **/*.js
```



## 3. 常用的模块化打包工具
## 4. 基于模块化工具构建现代 Web 应用
## 5. 打包工具的优化技巧

